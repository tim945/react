<!--
 * @Author: tim
 * @Date: 2020-03-18 09:32:16
 * @LastEditors: tim
 * @LastEditTime: 2020-03-20 11:35:18
 * @Description: 坚持看清问题、敢想、勤印证想法、并学以致用，可以极大地提高个人提升速度。保持这个节奏，持续若干年，即可达成“核心知识精通，周边知识“知道的足够多”。用有限的生命去思考那些最有价值的东西吧。
 * 其实，学习是一门投资。而对待投资，就要
* 算计投入产出
* 不要被别人牵着鼻子走，学能用得上的
* 找到有长期价值的学习目标。
 -->

# 核心概念

  ## JSX 特定属性 
  > 在属性中嵌入 JavaScript 表达式时，不要在大括号外面加上引号。你应该仅使用引号（对于字符串值）或大括号（对于表达式）中的一个，对于同一属性不能同时使用这两种符号。
  
  1. 你可以通过使用引号，来将属性值指定为字符串字面量： 
    ``` js
    const element = <div tabIndex="0"></div>;
    ```

  2. 使用大括号，来在属性值中插入一个 JavaScript 表达式 
    ``` js
    const element = <img src={user.avatarUrl}></img>;
    ```

  ::: tip
  因为 JSX 语法上更接近 JavaScript 而不是 HTML，所以 React DOM 使用 camelCase（小驼峰命名）来定义属性的名称，而不使用 HTML 属性名称的命名约定。

  例如，JSX 里的 class 变成了 className，而 tabindex 则变为 tabIndex。
  :::

  ## 元素渲染 
  > 元素是构成 React 应用的最小砖块。
  
  ``` js
  const element = (
    <h1>Hello, world</h1>
  );
  ReactDOM.render(element, document.getElementById('root'));
  ``` 

  ## 组件 & Props
  > 组件允许你将 UI 拆分为独立可复用的代码片段，并对每个片段进行独立构思。

  ### 函数组件与 class 组件
  1. 定义组件最简单的方式就是编写 JavaScript 函数：

    ``` js
    // 传入了 `props` 可以直接当变量使用
    function Welcome(props) {
      return <h1>Hello, {props.name}</h1>;
    }

    // 未传入 `props` 可以通过 `this.props` 获取属性
    function Welcome() {
      return <h1>Hello, {this.props.name}</h1>;
    }
    ```

  2. 使用 ES6 的 class 来定义组件：
    ``` js
    class Welcome extends React.Component {
      constructor(props) {
        super(props);
        this.state = {date: new Date()};
      }
      render() {
        return <h1>Hello, {this.props.name}</h1>;
      }
    }
    ```

  ### tip
  注意： 组件名称必须以大写字母开头。

  `React` 会将以小写字母开头的组件视为原生 `DOM` 标签。例如，`<div />` 代表 HTML 的 div 标签，而 `<Welcome />` 则代表一个组件，并且需在作用域内使用 `Welcome`。
  ###  

  ## State & 生命周期
  尽管 this.props 和 this.state 是 React 本身设置的，且都拥有特殊的含义，但是其实你可以向 class 中随意添加不参与数据流（比如计时器 ID）的额外字段。

  ``` js
  componentDidMount() {
    this.timerID = setInterval(
      () => this.tick(),
      1000
    );
  }

  componentWillUnmount() {
    clearInterval(this.timerID);
  }
  ```

  ### 正确地使用 State
  1. 不要直接修改 State
  ``` js
  // Wrong
  this.state.comment = 'Hello';

  // Correct
  this.setState({comment: 'Hello'});
  ```
  
  2. State 的更新可能是异步的
  > 出于性能考虑，React 可能会把多个 setState() 调用合并成一个调用。因为 this.props 和 this.state 可能会异步更新，所以你不要依赖他们的值来更新下一个状态。
  
  ``` js 
  // Wrong
  this.setState({
    counter: this.state.counter + this.props.increment,
  });

  // Correct
  this.setState((state, props) => ({
    counter: state.counter + props.increment
  }));
  ```

  3. 数据是向下流动的
  >  state 是局部。除了拥有并设置了它的组件，其他组件都无法访问。
  组件可以选择把它的 state 作为 props 向下传递到它的子组件中
  
  ``` html
  <FormattedDate date={this.state.date} />
  ```

  ``` js
  function FormattedDate(props) {
    return <h2>It is {props.date.toLocaleTimeString()}.</h2>;
  }
  ```

  ### 生命周期
  1. 挂载
  > 当组件实例被创建并插入 DOM 中时，其生命周期调用顺序如下：
  - constructor()
  - static getDerivedStateFromProps()
  - render()
  - componentDidMount()

  2. 更新
  > 当组件的 props 或 state 发生变化时会触发更新。组件更新的生命周期调用顺序如下：

  - static getDerivedStateFromProps()
  - shouldComponentUpdate()
  - render()
  - getSnapshotBeforeUpdate()
  - componentDidUpdate()

  3. 卸载
  > 当组件从 DOM 中移除时会调用如下方法：
  
  - componentWillUnmount()

  4. 错误处理
  > 当渲染过程，生命周期，或子组件的构造函数中抛出错误时，会调用如下方法：

  - static getDerivedStateFromError()
  - componentDidCatch()

  ## 事件处理
  > React 事件的命名采用小驼峰式（camelCase），而不是纯小写。使用 JSX 语法时你需要传入一个函数作为事件处理函数，而不是一个字符串

  ### 传统的 HTML：
  ``` html
  <button onclick="activateLasers()">
    Activate Lasers
  </button>
  ```

  ### 在 React 中略微不同：
  ``` html
  <button onClick={activateLasers}>
    Activate Lasers
  </button>
  ```

  ### 向事件处理程序传递参数
  > 在这两种情况下，React 的事件对象 e 会被作为第二个参数传递。如果通过箭头函数的方式，事件对象必须显式的进行传递，而通过 `bind` 的方式，事件对象以及更多的参数将会被隐式的进行传递。
  ``` html
  <button onClick={(e) => this.deleteRow(id, e)}>Delete Row</button>
  <button onClick={this.deleteRow.bind(this, id)}>Delete Row</button>
  ```  
  ### tips
  在 React 中另一个不同点是你不能通过返回 false 的方式阻止默认行为。你必须显式的使用 preventDefault 。
  ### 

  ## 条件渲染
  > React 中的条件渲染和 JavaScript 中的一样，使用 JavaScript 运算符 if 或者条件运算符去创建元素来表现当前的状态，然后让 React 根据它们来更新 UI。 

  ### 元素变量 
  > 可以使用变量来储存元素。 它可以帮助你有条件地渲染组件的一部分，而其他的渲染部分并不会因此而改变。
  ``` js
  render() {
    const isLoggedIn = this.state.isLoggedIn;
    let button;

    if (isLoggedIn) {
      button = <LogoutButton onClick={this.handleLogoutClick} />;
    } else {
      button = <LoginButton onClick={this.handleLoginClick} />;
    }

    return (
      <div>
        <Greeting isLoggedIn={isLoggedIn} />
        {button}
      </div>
    );
  }
  ```

  ### 与运算符 && 
  > 通过花括号包裹代码，你可以在 JSX 中嵌入任何表达式。这也包括 JavaScript 中的逻辑与 (&&) 运算符 
  ``` js 
  function Mailbox(props) {
    const unreadMessages = props.unreadMessages;
    return (
      <div>
        <h1>Hello!</h1>
        {unreadMessages.length > 0 &&
          <h2>
            You have {unreadMessages.length} unread messages.
          </h2>
        }
      </div>
    );
  }
  ``` 

  ### 三目运算符 
  > 用 JavaScript 中的三目运算符 condition ? true : false
  ``` js
  render() {
    const isLoggedIn = this.state.isLoggedIn;
    return (
      <div>
        The user is <b>{isLoggedIn ? 'currently' : 'not'}</b> logged in.
      </div>
    );
  }
  
  // 较为复杂的表达式
  render() {
    const isLoggedIn = this.state.isLoggedIn;
    return (
      <div>
        {isLoggedIn ? (
          <LogoutButton onClick={this.handleLogoutClick} />
        ) : (
          <LoginButton onClick={this.handleLoginClick} />
        )}
      </div>
    );
  }
  ```

  ### 阻止组件渲染
  > 在极少数情况下，你可能希望能隐藏组件，即使它已经被其他组件渲染。若要完成此操作，你可以让 `render` 方法直接返回 null，而不进行任何渲染
  ``` js
  function WarningBanner(props) {
    if (!props.warn) {
      return null;
    }

    return (
      <div className="warning">
        Warning!
      </div>
    );
  }
  ```


  





  

